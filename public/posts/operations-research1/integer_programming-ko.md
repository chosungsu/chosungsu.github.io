---
title: 'Integer programming'
date: '2024-07-29'
tags: ['Operations Research 1', 'lecture']
---

### integer programming vs linear programming relaxation

정수 프로그래밍에서 모든 결정 변수가 정수여야 하는 경우 pure IP 문제라고 합니다. 일부 결정 변수만 정수이면 되는 경우 mixed IP 문제라고 합니다. 모든 결정 변수가 0 또는 1이어야 하는 경우 0-1 IP 문제라고 합니다.

변수의 모든 정수 또는 0-1 제약 조건을 생략하여 얻은 LP 문제를 IP 문제의 LP 완화라고 합니다.

feasible region은 IP와 LP relaxation 중에 어느 쪽이 더 넓은 가와 최대화 문제에서 어느 최적의 $z$ 값이 더 큰가에 대한 질문에 LP relaxation이 더 넓다고 답할 수 있습니다. 그 이유는 LP relaxation은 변수가 정수와 분수 모두 취할 수 있기 때문에 가장 큰 $z$를 포함하는 넓은 옵션을 갖고 있습니다. 그리고 LP 문제에서 반올림으로 얻은 최적해는 실제 IP 문제의 최적해가 아닙니다.

---

### branch and bound

최소화 IP 또는 혼합 IP 문제는 목적 함수의 반대를 최대화함으로써 최대화 문제로 바꿀 수 있습니다. 우선 $z^*$를 음의 무한대로 설정합니다. 다음으로 branching 방법이라고 하는데 최근에 생성된 이해할 수 없는 하위 문제를 선택합니다. 하위 문제의 LP relaxation에 대한 최적 솔루션이 포함되지 않지만 정수가 되어야 하는 branch variable을 선택합니다. $x_j$가 branch variable이고 $x_j^*$가 최적해라고 할 때 각각 $x_j \le x_j^*$를 만족하는 lower, $x_j \ge x_j^*$를 만족하는 upper 함수를 추가하여 두 개의 새로운 하위 문제를 만듭니다. 다음으로 bounding 방법이라고 하는데 각각 새로운 하위 문제에 대해 LP relaxation의 최적 $z$값을 구합니다. 이는 하위 문제의 분기상한입니다.

아래의 세가지 테스트 중 하나라도 참이면 새로운 하위 문제를 파악한 것으로 표시합니다.

-$z \le z^*$

-LP relaxation에는 실행 가능한 솔루션이 없습니다.

-LP relaxation에 대한 최적 솔루션은 모든 정수 제한 변수에 대해 정수 값을 갖습니다. 이 테스트가 사실이면 $z^*$를 업데이트하고 F1을 다시 테스트해야 합니다.

새로운 하위 문제가 파악되면 현재의 $z^*$가 최적이고 branching으로 돌아갑니다.

#### MIP(Mixed Integer Programming)

max $z=4x_1-2x_2+7x_3-x_4$를 갖는 최대화 문제가 있고 제약 조건이 $x_1+5x_3 \le 10$, $x_1+x_2-x_3 \le 1$, $6x_1-5x_2 \le 0$, $-x_1+2x_3-2x_4 \le 3$이 있고 모든 제약 변수는 0보다 큰 경우의 문제는 LP relaxation이고 추가로 정수로만 존재하는 경우를 적었다면 MIP로 생각할 수 있습니다.

우선 $z^*$를 음의 무한대로 보내면 simplex method를 통해 풀이하면 $(x_1, x_2, x_3, x_4)=(1.25, 1.5, 1.75, 0)$ 일 때 $z=14.25$라고 합니다. 하지만 $z$ 값이 음의 무한대보다 작거나 같지 않습니다. 또한 결정 변수들이 정수가 아니기 때문에 추가 계산이 필요합니다. 검색 공간을 $x_1 \le 1$, $x_1 \ge 2$로 나누고 첫번째 하위 문제는 $(x_1, x_2, x_3, x_4)=(1, 1.2, 1.8, 0)$로 나오지만 두번째 하위 문제는 실행 불가능하였습니다. 첫번째 하위 문제에 대해서 이를 다시 $x_2 \le 1$, $x_2 \ge 2$로 두 개의 새로운 하위 문제를 만듭니다. 첫번째 하위 문제는 $(x_1, x_2, x_3, x_4)=(0.83, 1, 1.83, 0)$, 두번째 하위 문제는 $(x_1, x_2, x_3, x_4)=(0.83, 2, 1.83, 0)$는 모두 이해 불가한 부분이라 $x_1=0$, $x_1=1$라는 새로운 하위 문제를 만듭니다. 첫번째 하위 문제는 $(x_1, x_2, x_3, x_4)=(0, 0, 2, 0.5)$, 두번째 하위 문제는 실행 불가능하였습니다. 이 때 결정 변수가 정수이므로 $z^*=z=13.5$로 업데이트합니다.

#### BIP(Binary Integer Programming)

max $z=9x_1+5x_2+6x_3+4x_4$를 갖는 최대화 문제가 있고 제약 조건이 $6x_1+3x_2+5x_3+2x_4 \le 10$, $x_3+x_4 \le 1$, $-x_1+x_3 \le 0$, $-x_2+x_4 \le 0$이 있고 모든 제약 변수는 0보다 큰 경우의 문제는 LP relaxation이고 추가로 0, 1로만 존재하는 경우를 적었다면 BIP로 생각할 수 있습니다.

우선 $z^*$를 음의 무한대로 보내면 simplex method를 통해 풀이하면 $(x_1, x_2, x_3, x_4)=(0.83, 1, 0, 1)$ 일 때 $z=16$라고 합니다. $x_1$이 0 또는 1인 정수가 아니므로 이를 branch variable로 정하여 새 하위 문제를 만듭니다. 첫번째 하위 문제는 $x_1=0$, 두번째 하위 문제는 $x_1=1$입니다. simplex method로 풀이하면 $(x_1, x_2, x_3, x_4)=(0, 1, 0, 1)$에 $z=9$이고 두번째 하위 문제는 $(x_1, x_2, x_3, x_4)=(0, 0.8, 0, 0.8)$에 $z=16$가 되는데 첫번째 하위문제가 제약 조건을 만족하므로 $z^*=z=9$로 업데이트합니다. 두번쨰 하위 문제에서는 $x_2$를 branch variable로 정하고 새 하위 문제를 만듭니다. 첫번째 하위 문제는 $x_2=0$, 두번째 하위 문제는 $x_2=1$입니다. simplex method로 풀이하면 $(x_1, x_2, x_3, x_4)=(1,0,0.8,0)$에 $z=13$이고 두번째 하위 문제는 $(x_1, x_2, x_3, x_4)=(1,1,0,0.5)$에 $z=16$가 되는데 두 문제 모두 이해 불가한 부분이므로 계속 새 하위 문제를 만드는데 첫번째 하위 문제는 $x_4=0$, 두번째 하위 문제는 $x_4=1$입니다. 그 결과는 첫번째 하위 문제에서는 $(x_1, x_2, x_3, x_4)=(1, 1, 0, 0)$에 $z=14$이고 두번째 하위 문제는 실행 불가능했습니다. 이 $z$값이 더 좋으므로 $z^*=z=14$로 업데이트합니다.

---

### knapsack problem

예를 들어 john의 아파트에 불이 나서 귀중품 몇 개를 챙겨 밖으로 나가야 할 때 아래와 같이 무게와 가치를 담은 tableau를 참고해야 합니다.

| item | weight | value | value/weight |
|----------|---------|----------|----------|
| 1 | 5 | 16 | 16/5=3.2 |
| 2 | 7 | 22 | 22/7=3.14 |
| 3 | 4 | 12 | 12/4=3 |
| 4 | 3 | 8 | 8/3=2.67 |

그는 최대 14파운드의 무게를 담는 배낭을 하나만 사용할 수 있고 이에 따라 가능한 아이템은 무엇이 되는지 계산을 해보겠습니다. 우선 결정 변수는 $x_j$로 하고 john이 해당 아이템을 챙겼다면 1 아니면 0을 넣습니다. 목적 함수는 max $z=16x_1+22x_2+12x_3+8x_4$이고 제약 조건은 $5x_1+7x_2+4x_3+3x_4 \le 14$이고 $x_j=0$ 또는 $x_j=1$로 BIP로 풀 수 있습니다.

먼저 각 품목의 value/weight 값을 계산합니다. 가장 좋은 아이템을 먼저 넣고 그 다음으로 좋은 아이템을 넣는 식으로 넘치기 전까지 반복하면 됩니다. 그리고 남는 공간은 분수로 생각합니다. 위 tableau에서 가장 좋은 1번을 넣고 9파운드가 남으므로 다시 좋은 2번을 넣고 2파운드가 남습니다. 남는 공간에 통째로 들어가는 아이템은 없지만 3번은 절반을 넣을 수 있으므로 0.5로 판단합니다. 남은 4번은 넣을 수 없으므로 0으로 하면 $z=16+22+12*0.5=44$로 최적해를 구합니다.

---

### job shop scheduling problem

단일 기계에서 처리해야 하는 작업은 $n$이고 각 작업의 기간과 마감일을 알고 있으며 총 작업일의 최소화를 위한 문제입니다. 즉 $n!$개의 방법이 존재합니다.

| job | duration | due date |
|----------|---------|----------|
| $A$ | 6 | day 8 |
| $B$ | 4 | day 4 |
| $C$ | 5 | day 12 |

이 tableau에서 작업 순서를 $(A, B, C)$로 정한다면 아래와 같습니다. delay가 음수이면 더 빨리 끝난다는 의미로 0으로 수렴 시킵니다.

| job | completion | delay |
|----------|---------|----------|
| $A$ | 6 | $6-8=-2 \rightarrow 0$ |
| $A, B$ | 6+4=10 | 10-4=6 |
| $A, B, C$ | 6+4+5=15 | 15-12=3 |

이 작업의 총 지연시간 $T=0+6+3=9$입니다. 이는 순서 중 하나에 해당하며 branch-bound 방법을 사용하여 해결할 수 있습니다. 결정 변수 $x_{ij}$는 job $j$가 $i$번째 포지션에 배치되면 1 그렇지 않으면 0으로 표시합니다.

예를 들어 $x_{3A}=1$, $x_{3B}=1$, $x_{3C}=1$ 과 같이 마지막 노드에 각 job을 넣습니다. 이 때 완료시점은 15로 첫번째 경우 지연 시간은 $(15-8=7, 15-4=11, 15-12=3)$ 일이 됩니다. 이 중 가장 지연 시간이 적은 세번째 경우에 새로운 하위 문제로 두번째 노드에 $A$와 $B$를 넣는 문제를 만듭니다. 첫번째 문제는 $A$까지 완료시점은 총 15-5=10으로 지연 시간은 10-8=2일과 기존 지연 시간 3일을 더하여 5일 입니다. 두번째 문제는 완료시점은 총 15-5=10으로 지연 시간은 10-4=6일과 기존 지연 시간 3일을 더하여 9일 입니다. 마지막으로 둘 중 가장 짧은 지연 시간을 갖는 첫번째 문제로부터 $BAC$ 순으로 생각하면 완료시점은 총 15-5-6=4로 지연 시간은 4-4=0일과 기존 지연 시간 5일을 더하여 5일입니다.

따라서 가장 최적의 작업일은 15일에 지연 시간 5일로 판단할 수 있습니다.

---

### traveling salesman problem

비지니스를 위해 city 1~5까지 한 번씩 방문을 하되 시작한 도시로 돌아와야 하는 문제입니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | $M$ | 132 | 217 | 164 | 58 |
| city2 | 132 | $M$ | 290 | 201 | 79 |
| city3 | 217 | 290 | $M$ | 113 | 303 |
| city4 | 164 | 201 | 113 | $M$ | 196 |
| city5 | 58 | 79 | 303 | 196 | $M$ |

위 tableau에서 결정 변수는 $c_{ij}$는 city $i$에서 city $j$까지의 거리로 생각합니다. 이 때 $M$으로 표시한 지점은 같은 도시끼리 이동하지 않도록 충분히 큰 양수로 표시한 것입니다. 이 결정 변수는 그 도시에 방문한다면 1 그렇지 않다면 0으로 표시합니다. 각 도시에 대한 보조 변수 $u_i$를 정의합니다.

목적 함수는 min $z=\sum_{i=1}^{N}\sum_{j=1}^{N} c_{ij}x_{ij}$로 정의하고 제약 조건은 $\sum_{i=1}^{N} x_{ij}=1$로 방문을 1회만 가능하도록 제한하고 $\sum_{j=1}^{N} x_{ij}=1$로 떠나는 도시를 1회만 가능하도록 제한하고 $u_i-u_j+Nx_{ij} \le N-1$로 하위 이동(1->2->3->1)과 같이 다 이동을 하지 않는 경우가 없음을 보장합니다.

#### hungarian method

우선 행렬에서 각 행의 최소 비용을 찾습니다. 각 비용에서 해당 행의 최소 비용을 뺍니다. 수정된 행렬에서 각 열의 최소 비용을 찾고 마찬가지로 뺍니다. 다음으로 0이 있는 셀에서 자신을 제외한 같은 행의 최소값과 같은 열의 최소값을 더하여 모든 0의 페널티를 계산합니다. 가장 큰 페널티를 주는 0을 고릅니다. 행에서 열까지의 arc를 방문에 포함합니다. 이후에 해당 행과 열을 지웁니다.

위의 tableau를 사용하여 각 행의 최소값을 구하면 $(R_1, R_2, R_3, R_4, R_5) = (58, 79, 113, 113, 58)$ 이므로 이 값을 행마다 뺀다면 아래와 같이 수정됩니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | $M$ | 74 | 159 | 106 | 0 |
| city2 | 53 | $M$ | 211 | 122 | 0 |
| city3 | 104 | 177 | $M$ | 0 | 190 |
| city4 | 51 | 88 | 0 | $M$ | 83 |
| city5 | 0 | 21 | 245 | 138 | $M$ |

이제 각 열의 최소값을 구하면 $(C_1, C_2, C_3, C_4, C_5) = (0, 21, 0, 0, 0)$ 이므로 이 값을 열마다 뺀다면 아래와 같이 수정됩니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | $M$ | 53 | 159 | 106 | 0 |
| city2 | 53 | $M$ | 211 | 122 | 0 |
| city3 | 104 | 156 | $M$ | 0 | 190 |
| city4 | 51 | 67 | 0 | $M$ | 83 |
| city5 | 0 | 0 | 245 | 138 | $M$ |

다음으로 0이 있는 셀에서 페널티를 구하면 $p_{15}=53+0=53$, $p_{25}=53+0=53$, $p_{34}=104+106=210$, $p_{43}=51+159=210$, $p_{51}=0+51=51$, $p_{52}=0+53=53$ 와 같습니다. 가장 큰 페널티를 주는 셀은 $p_{34}=p_{43}=210$으로 동일하므로 임의로 하나를 선택하면 $C \rightarrow D$를 arc로 넣습니다. 역방향은 고려하지 않습니다. 따라서 3행 4열을 지운 다음 역방향 아크에 해당하는 셀도 지웁니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | - | 53 | 159 | - | 0 |
| city2 | 53 | - | 211 | - | 0 |
| city3 | - | - | - | $C \rightarrow D$ | - |
| city4 | 51 | 67 | - | - | 83 |
| city5 | 0 | 0 | 245 | - | - |

다시 반복한다면 각 행의 최소값은 $(R_1, R_2, R_4, R_5) = (0, 0, 51, 0)$ 이므로 이 값을 행마다 뺀다면 아래와 같이 수정됩니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | - | 53 | 159 | - | 0 |
| city2 | 53 | - | 211 | - | 0 |
| city3 | - | - | - | $C \rightarrow D$ | - |
| city4 | 0 | 16 | - | - | 32 |
| city5 | 0 | 0 | 245 | - | - |

이제 각 열의 최소값을 구하면 $(C_1, C_2, C_3, C_5) = (0, 0, 159, 0)$ 이므로 이 값을 열마다 뺀다면 아래와 같이 수정됩니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | - | 53 | 0 | - | 0 |
| city2 | 53 | - | 52 | - | 0 |
| city3 | - | - | - | $C \rightarrow D$ | - |
| city4 | 0 | 16 | - | - | 32 |
| city5 | 0 | 0 | 86 | - | - |

다음으로 0이 있는 셀에서 페널티를 구하면 $p_{13}=0+52=52$, $p_{15}=0+0=0$, $p_{25}=52+0=52$, $p_{41}=16+0=16$, $p_{51}=0+0=0$, $p_{52}=0+16=16$ 와 같습니다. 가장 큰 페널티를 주는 셀은 $p_{13}=p_{25}=52$으로 동일하므로 임의로 하나를 선택하면 $A \rightarrow C$를 arc로 넣습니다. 역방향은 고려하지 않습니다. 따라서 1행 3열을 지운 다음 역방향 아크에 해당하는 셀도 지웁니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | - | - | $A \rightarrow C$ | - | - |
| city2 | 53 | $M$ | - | - | 0 |
| city3 | - | - | - | $C \rightarrow D$ | - |
| city4 | 0 | 16 | - | - | 32 |
| city5 | 0 | 0 | - | - | - |

각 행과 열의 최소 값은 0으로 넘어가고 다음으로 0이 있는 셀에서 페널티를 구하면 $p_{25}=53+32=85$, $p_{41}=16+0=16$, $p_{51}=0+0=0$, $p_{52}=0+16=16$ 와 같습니다. 가장 큰 페널티를 주는 셀은 $p_{25}=85$로 $B \rightarrow E$를 arc로 넣습니다. 역방향은 고려하지 않습니다. 따라서 2행 5열을 지운 다음 역방향 아크에 해당하는 셀도 지웁니다.

|  | city1 | city2 | city3 | city4 | city5 |
|----------|---------|----------|----------|---------|----------|
| city1 | - | - | $A \rightarrow C$ | - | - |
| city2 | - | $M$ | - | - | - |
| city3 | - | - | - | $C \rightarrow D$ | - |
| city4 | 0 | 16 | - | - | - |
| city5 | 0 | - | - | - | - |

각 행의 최소 값은 0이라 넘어가고 각 열의 최소값은 (0, 16)이므로 뺍니다. 이후 각 0들의 페널티는 모두 0이 됩니다. 임의로 5행 1열의 셀을 고르면 $E \rightarrow A$를 arc로 넣습니다. 역방향은 고려하지 않습니다. 마지막으로 남은 셀 4행 2열의 $D \rightarrow B$를 arc로 넣으면 종료됩니다.

따라서 $A \rightarrow C \rightarrow D \rightarrow B \rightarrow E \rightarrow A$ 경로가 됩니다. 해당 경로의 총 길이는 $217+113+201+79+58=668$입니다.

---

### 참고 자료

[원본 경로 #1](https://youtu.be/vHXishYefss?si=a3cFJeyfiK3gGbDW)

[원본 경로 #2](https://youtu.be/tBUfL3O_Nzg?si=znxz_y5DuDZXINVu)

[원본 경로 #3](https://youtu.be/KhDv42KC5KM?si=tVLAnkyoC0N-4nfH)

[원본 경로 #4](https://youtu.be/UGvc-qujB-o?si=li6qKG445JcepXaD)

[원본 경로 #5](https://youtu.be/nRJSFtscnbA?si=bCa_L5KSPeb9oAMv)

[원본 경로 #6](https://youtu.be/gSJGAaC8VT4?si=MCAqkDJSYcWLd-xJ)