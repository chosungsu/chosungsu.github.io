---
title: 'Heap'
date: '2023-08-22'
tags: ['Data Structure', 'lecture']
---

### Preliminary

힙(Heap)은 단순한 트리 데이터 구조로 생각할 수 있지만, 일반적으로 두 가지 전략 중 하나를 사용합니다.

최소 힙은 각 부모 노드의 값이 자식 노드의 값보다 작거나 같다 ($\le$)는 속성을 가집니다. 따라서 루트 노드는 트리 전체에서 가장 작은 값을 가집니다.

최대 힙은 각 부모 노드의 값이 자식 노드의 값보다 크거나 같다 ($\ge$)는 속성을 가집니다. 따라서 루트 노드는 트리 전체에서 가장 큰 값을 가집니다.

---

### 기본 구조

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTrhJjBCRB95EcVLrwAa5JqPZPD4BboTANzKw&s" alt="Example Image" style="display: block; margin: 0 auto; height:150;" />

노드는 위에서 아래로, 왼쪽에서 오른쪽으로 값을 배열에 순차적으로 추가하여 저장됩니다.

배열을 사용하기 때문에, 주어진 색인(index)을 사용하여 부모 노드와 자식 노드의 색인을 계산하는 방법이 필요합니다. 색인 $i$에 대한 계산 공식은 다음과 같습니다.

부모 색인은 $(i-1)/2$, 왼쪽 자식은 $2 \times i + 1$, 오른쪽 자식은 $2 \times i + 2$와 같습니다.

힙 삽입은 간단하지만, 삽입 후 힙 순서(heap order)가 유지되도록 해야 합니다. 실행 시간은 $O(1)$이지만 순서 검증으로 인하여 $O(\log n)$만큼 가집니다.

항목을 삭제하는 것도 힙 순서가 유지되도록 보장해야 합니다. 실행 시간은 $O(\log n)$입니다. 이후 삭제된 자리에 들어온 새 값은 너무 클 수 있으므로, 힙 순서를 복원하기 위해 더 작은 자식과 교환하면서 아래로 내려갑니다.

탐색은 가장 간단한 방법은 힙 배열의 항목을 순차적으로 순회하는 것입니다. 따라서 실행 시간은 $O(n)$이 됩니다.

---

### 참고 자료

[원본 경로 #1](https://mta.ca/~rrosebru/oldcourse/263111/Dsa.pdf)
