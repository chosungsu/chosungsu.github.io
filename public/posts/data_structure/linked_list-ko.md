---
title: 'Linked List'
date: '2023-08-08'
tags: ['Data Structure', 'lecture']
---

### Preliminary

연결 리스트는 고수준 관점에서 일련의 노드(nodes)로 생각할 수 있습니다. 각 노드는 다음 노드를 가리키는 포인터(pointer)를 최소한 하나 가지고 있으며, 마지막 노드의 경우 널 포인터(null pointer)를 통해 목록의 끝을 나타냅니다.

연결 리스트는 항상 헤드(head)와 테일(tail) 포인터를 유지하여, 리스트의 앞 또는 뒤에 삽입하는 작업이 상수 시간($O(1)$) 연산이 되도록 합니다. 임의의 위치에 삽입(Random insertion)은 이에 해당하지 않으며 선형 시간($O(n)$) 연산이 됩니다.

---

### 기본 구조

삽입은 연결 리스트의 가장 큰 장점 중 하나입니다. 헤드와 테일 노드에 대한 포인터(또는 참조)를 유지함으로써, 리스트의 앞 또는 뒤에 노드를 추가하는 것은 $O(1)$ 연산이 됩니다.

그러나 예외적으로 싱글 연결 리스트에서 헤드나 테일이 아닌 노드 앞에 삽입을 수행하는 경우, 삽입할 지정된 노드의 이전 노드(predecessor)를 찾기 위해 리스트를 순회해야 합니다. 이 순회는 $O(n)$ 실행 시간을 발생시킵니다.

연결 리스트의 주요 장점으로는 리스트 크기가 동적으로 조정되므로, 배열이나 벡터가 결국 발생시키는 복사 페널티(copy penalty)가 없는 동적 크기 조정을 말할 수 있습니다.

#### 1. 단일 연결 리스트 (Singly Linked List)

<img src="https://velog.velcdn.com/images/devjo/post/1f21231d-8d8c-480f-8ab7-e3e7aaa2b3ed/image.png" alt="Example Image" style="display: block; margin: 0 auto; height:50;" />

각 노드는 값(value)과 리스트의 다음 노드에 대한 참조(reference)로 구성됩니다. 일반적으로 연결 리스트에 대한 삽입은 노드를 리스트의 테일(꼬리)에 추가하는 것을 의미합니다.

연결 리스트를 탐색하는 것은 리스트를 순회하면서 찾고자 하는 값과 각 노드의 값을 비교하는 것으로 실행 시간은 $O(n)$입니다.

노드를 삭제하는 것은 까다롭지 않지만 빈 리스트, 유일한 노드, 헤드 노드, 테일 노드, 중간 노드, 없는 항목 등 경우의 수가 많습니다. 일반적으로 삭제는 $O(n)$ 연산이고 리스트의 맨 앞에서만 삭제가 일어나는 경우에 한하여 $O(1)$ 연산이 됩니다.

단일 연결 리스트는 앞으로만 이동할 수 있는 구조를 가지고 있으므로, 역순 순회는 매우 비효율적입니다. 각 노드의 이전 노드(predecessor)를 찾기 위해 매번 리스트를 처음부터 순회해야 합니다. 각 노드에 대해 $O(n)$이 소요되므로, 전체 역순 순회는 $O(n^2)$ 비용이 발생합니다.

#### 2. 이중 연결 리스트 (Doubly Linked List)

<img src="https://velog.velcdn.com/images/devjo/post/337023cb-91b4-4a83-a6be-bd861a55461f/image.png" alt="Example Image" style="display: block; margin: 0 auto; height:50;" />

이중 연결 리스트는 싱글 연결 리스트와 매우 유사하지만, 각 노드가 다음(Next) 노드뿐만 아니라 이전(Prev) 노드에 대한 참조도 가집니다.

싱글 리스트와 달리, 새 노드를 삽입할 때 이전 포인터($n.Prev$)도 올바른 값으로 바인딩해야 합니다. 실행 시간은 $O(1)$입니다.

이중 연결 리스트의 삭제는 싱글 리스트와 동일한 경우를 사용하지만, 추가적으로 이전(Prev) 참조도 바인딩해야 합니다. 실행 시간은 $O(n)$입니다. 노드 $n$을 삭제할 때, $n.Prev.Next$와 $n.Next.Prev$를 모두 업데이트하여 $n$을 건너뛰도록 만듭니다.

이중 연결 리스트는 각 노드가 이전 노드를 알고 있기 때문에 역순 순회가 매우 간단하고 효율적입니다. 싱글 연결 리스트의 $O(n^2)$와 달리, $O(n)$ 시간에 수행됩니다.

---

### 참고 자료

[원본 경로 #1](https://mta.ca/~rrosebru/oldcourse/263111/Dsa.pdf)
