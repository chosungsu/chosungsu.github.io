---
title: 'BTree and Nosql'
date: '2022-04-22'
tags: ['Database', 'lecture']
---

### B-Tree

이는 1972년에 소개된 균형 잡힌 트리 구조로, 블록(페이지) 단위로 데이터를 읽고 쓰는 디스크 기반 시스템에 최적화된 자료구조입니다.

트리의 각 노드(Node)는 디스크의 단일 블록(페이지) 크기에 맞게 설계됩니다. 이는 한 번의 디스크 I/O로 노드 전체를 메모리로 로드할 수 있게 합니다. 루트 노드에서 어떤 리프 노드(Leaf Node)로 가는 경로든 항상 길이가 같습니다. 이 특징 덕분에 최악의 경우(Worst-case)에도 검색 시간이 일정하게 유지됩니다. 각 노드는 많은 수의 자식 노드를 가리키는 포인터와 키(Key) 값들을 포함할 수 있습니다. 노드 크기가 클수록 분기 계수가 높아져 트리의 높이가 낮게 유지됩니다.

B-Tree의 차수($M$)는 노드가 가질 수 있는 최대 자식 노드의 수를 정의합니다. 내부 노드는 $(K, P)$ 쌍의 배열로 구성됩니다. 노드에 $m$개의 자식이 있다면, $m-1$개의 키를 저장합니다. 특정 키 값보다 작거나 같은 튜플은 왼쪽 포인터로, 큰 튜플은 오른쪽 포인터로 탐색하도록 합니다.

B-Tree는 데이터의 삽입과 삭제 시에도 트리의 균형을 유지하기 위해 복잡한 연산을 수행합니다. 키를 삽입할 노드가 가득 찬 경우, 해당 노드를 두 개의 노드로 나누는 분할(Splitting) 연산을 수행하고, 중앙 키를 부모 노드로 올립니다. 키를 삭제한 후 노드의 키 개수가 최소 기준 미만이 되면 형제 노드로부터 키를 재분배(Redistribution)하거나, 노드를 병합(Merging)하여 트리의 높이 및 최소 용량을 유지합니다.

---

### B⁺-Tree

대부분의 현대 DBMS 인덱스는 $\text{B}^{+}$-Tree를 사용합니다. $\text{B}^{+}$-Tree는 $\text{B}$-Tree의 변형으로, 디스크 I/O 최적화에 더 특화된 구조입니다.

$\text{B}^{+}$-Tree는 데이터 저장 위치를 내부 노드와 리프 노드로 명확히 분리합니다. 내부 노드에는 오직 검색 키와 자식 노드 포인터만을 저장합니다. 실제 데이터 포인터는 저장하지 않으므로, 더 많은 키를 저장하여 분기 계수를 극대화할 수 있습니다. 리프 노드에는 검색 키와 실제 데이터 레코드에 대한 포인터(Data Pointer)를 저장합니다. 모든 데이터 포인터는 리프 노드에만 존재합니다. 모든 리프 노드들은 Linked List로 연결되어 있습니다.

$\text{B}^{+}$-Tree는 Linked List 덕분에 특정 범위($K_1$에서 $K_2$ 사이)의 데이터를 찾을 때, 트리의 루트에서 시작 지점($K_1$)만 찾은 후에는 내부 노드를 다시 거치지 않고 연결된 리프 노드를 따라 순차적으로 빠르게 탐색할 수 있습니다. 모든 검색 경로는 항상 리프 노드에서 끝나기 때문에, 검색 시간이 예측 가능하고 안정적입니다. 내부 노드가 데이터 포인터를 저장하지 않으므로 더 적은 디스크 I/O로 효율을 높입니다.

---

### Clustered Index & Non-Clustered Index

클러스터형 인덱스는 인덱스의 리프 노드가 실제 데이터 레코드 자체를 포함합니다. 테이블당 하나만 생성할 수 있으며 데이터 레코드가 인덱스 키 순서에 따라 물리적으로 정렬됩니다. 검색 속도가 가장 빠르지만, 데이터 삽입/갱신 시 물리적 재정렬이 발생할 수 있습니다.

비클러스터형 인덱스는 인덱스의 리프 노드가 실제 데이터 레코드 대신 데이터 레코드의 물리적 위치(주소 또는 기본 키)를 가리키는 포인터만을 저장합니다. 테이블당 여러 개를 생성할 수 있으며 인덱스를 통해 데이터를 찾은 후에는 해당 포인터를 이용해 데이터 파일에 한 번 더 접근해야 합니다.

---

### NoSQL

빅데이터는 주로 세 가지 $\text{V}$로 특징지어집니다. 이 세 가지 $\text{V}$는 RDBMS의 수평 확장 및 유연성을 저해하는 근본적인 원인이 됩니다.

규모(Volume) 측면에서 데이터의 양이 기가바이트(GB)를 넘어 테라바이트(TB), 페타바이트(PB) 수준으로 증가함에 따라 데이터를 단일 서버에 저장하고 처리하는 수직적 확장(Scale-up) 방식은 비용 효율성과 성능 면에서 한계에 도달했습니다.

속도(Velocity) 측면에서 소셜 미디어나 $\text{IoT}$ 기기에서 발생하는 데이터처럼 실시간으로 대량의 읽기/쓰기 요청을 처리해야 하는 요구가 커졌습니다.

다양성(Variety) 측면에서 기존의 정형 데이터뿐만 아니라 로그, 문서, 그래프, 센서 데이터와 같은 비정형/반정형 데이터의 비중이 증가했습니다.

#### CAP and Base

분산 시스템은 다음 세 가지 속성 중 최대 두 가지만 동시에 만족시킬 수 있다는 이론적 한계입니다. 일관성(Consistency)은 모든 클라이언트가 동일 시점에 동일한 데이터를 볼 수 있도록 보장합니다. 가용성(Availability)는 클라이언트의 모든 요청에 대해 항상 응답을 받을 수 있도록 보장합니다. 마지막으로 분할 내성(Partition Tolerance)는 네트워크 문제로 인해 시스템이 분리되어도 시스템이 계속 작동해야 합니다.

NoSQL 시스템은 네트워크 환경에서 분할 내성(P)을 포기할 수 없기 때문에 일반적으로 일관성(C)을 완화하고 가용성(A)을 선택합니다 (AP 시스템).

ACID의 강력한 보장 대신 BASE 원칙을 따릅니다. 기본적 가용(Base Available)에 따라 시스템은 장애 발생 시에도 최대한 작동 상태를 유지하며 요청에 응답합니다. 유동적 상태(Soft state)에 따라 데이터의 상태는 시간이 지남에 따라 변경될 수 있으며 즉각적인 일관성을 보장하지 않습니다. 최종 일관성(Eventually Consistent)에 따라 일정 시간 후에는 모든 복제본의 데이터가 일치하게 됩니다.

#### Model Structure

Key-Value Store는 단순한 모델로 Redis, Memcached가 예시로 고유한 키(Key)와 그 키에 연결된 값(Value)의 쌍으로 데이터를 저장합니다. 값은 문자열, 객체, 리스트 등 다양한 형태가 될 수 있습니다. 키를 이용한 검색, 삽입, 삭제가 $\text{O}(1)$ 시간 복잡도에 가까워 매우 빠릅니다.

Document Database는 MongoDB, Couchbase가 예시로 데이터를 계층적 구조를 가진 문서(Document) 형태로 저장합니다. 하나의 문서가 하나의 레코드에 해당하며 관련 데이터가 단일 문서 내에 중첩되어 저장될 수 있습니다. 테이블 구조를 미리 정의할 필요가 없어 새로운 필드 추가 및 데이터 구조 변경이 매우 자유롭습니다.

Column-Family Store는 Cassandra, HBase가 예시로 데이터를 행 단위가 아닌 열의 집합인 컬럼 패밀리 단위로 저장하고 관리합니다. 각 행은 키(Row Key)를 가지며 열들은 컬럼 패밀리별로 그룹화되어 물리적으로 저장됩니다. 데이터의 무작위 액세스보다는 순차적 읽기 및 쓰기 성능에 최적화되어 있습니다.

Graph Database는 Neo4j가 예시로 데이터를 노드(Node)와 엣지(Edge), 그리고 속성(Properties)을 사용하여 저장하며, 객체 간의 관계 자체를 저장하고 최적화합니다. 복잡한 다대다(M:N) 관계와 깊은 연결 경로를 탐색하는 질의(예: 소셜 네트워크 분석)에서 Join 연산보다 훨씬 빠르고 효율적입니다.

---

### 참고 자료

[원본 경로 #1](https://courses.cs.washington.edu/courses/cse373/15wi/lectures/lecture15.pdf)

[원본 경로 #2](https://www.cs.umd.edu/class/fall2019/cmsc420-0201/Lects/lect09-btree.pdf)

[원본 경로 #3](https://tropars.github.io/downloads/lectures/LSDM/LSDM-5.1-nosql-fundamentals.pdf)