---
title: 'Memory Management'
date: '2022-05-20'
tags: ['Operating System', 'lecture']
---

### Memory Management

Physical memory is the address space of the actual RAM chips in a computer system—it represents hardware-level physical addresses. Logical memory or virtual address space is generated by the CPU and used by processes. Each process has an independent logical address space, which the OS translates into physical addresses. The base register stores the physical start address mapped to logical address 0 of a process, and the limit register stores the process’s maximum size.

There are two broad ways to place processes in memory.

Contiguous allocation assigns the entire logical address space of a process to a single contiguous block of physical memory. Non-contiguous allocation scatters a process’s logical address space across multiple locations in physical memory.

#### Fragmentation

External fragmentation occurs when total physical memory is sufficient but there is no contiguous free block large enough for a process. Internal fragmentation occurs when the allocated block is larger than the process needs, leaving unused space inside the block.

Compaction gathers scattered free space into a single large block to address external fragmentation, but it consumes significant CPU time and adds overhead.

The Buddy System manages memory in chunks of size $2^k$, enabling efficient splitting and merging. A Slab Allocator caches small, frequently used kernel objects to minimize internal fragmentation and speed up object creation/destruction.

---

### Paging, Segmentation, and Virtual Memory

Paging divides a process’s logical address space into fixed-size pages and physical memory into frames of the same size. A logical address is split into a page number and an offset; the page number is translated via the page table into the frame number where that page resides in physical memory.

The Translation Lookaside Buffer (TLB) is a small, fast hardware cache that stores recently translated logical–physical address pairs to avoid a second memory access for page table lookup on every memory reference.

Multilevel page tables split the page table itself into pages so that unused portions need not be resident, improving space efficiency for very large address spaces (e.g., 64-bit systems). An inverted page table has one entry per physical frame, storing the process ID and logical page number. It saves space but can take longer due to table-wide searches.

Segmentation divides a process’s logical address space into meaningful logical units—segments—such as code, data, and stack.

Virtual memory provides each process with a large address space independent of physical memory size, loading only the code and data actually needed. Programs larger than physical memory can still run, increasing CPU utilization and throughput.

---

### Page Replacement

Demand paging loads into memory only the pages a process actually needs, leaving the rest on disk (swap space). Most virtual memory systems use this approach. A page fault is a trap raised when the page for a referenced logical address is not in physical memory; the needed page is then fetched from swap into a free frame.

Thrashing occurs when a process spends more time paging than executing—typically under memory pressure, frequent page faults occur because required pages cannot stay resident. The minimal set of pages a process needs to run efficiently is called its working set.

If no free frame exists when a page fault occurs, a victim frame must be chosen and evicted to disk. The optimal goal is to evict the page that will not be used for the longest time. FIFO evicts the page that entered memory first. LRU evicts the page least recently used, assuming recent past usage predicts near-future usage. The Clock algorithm is a practical approximation of LRU: each page keeps a reference bit; scanning in clock order replaces a page with reference bit 0, while pages with bit 1 are cleared and skipped.

---

### 참고 자료

[원본 경로 #1](https://www.cis.upenn.edu/~lee/03cse380/lectures/ln2-process-v4.pdf)

[원본 경로 #2](https://www.cl.cam.ac.uk/teaching/1011/OpSystems/os1a-slides.pdf)
