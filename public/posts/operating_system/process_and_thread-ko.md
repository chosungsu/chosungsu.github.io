---
title: 'Process and Thread'
date: '2022-05-13'
tags: ['Operating System', 'lecture']
---

### Process & Thread Fundamentals

프로그램은 디스크에 저장되어 있는 수동적인 실행 파일 자체를 의미합니다. 단순히 명령어와 데이터의 묶음입니다. 프로세스는 실행을 위해 메모리에 로드되어 CPU에 의해 실행되고 있는 동적인 실행 단위입니다.

#### 프로세스 제어 블록 (PCB)

운영체제가 시스템 내의 모든 프로세스에 대한 정보를 저장하고 관리하는 핵심 자료구조입니다. 프로세스의 ID, 현재 상태, CPU 레지스터 값, 메모리 관리 정보, 파일 I/O 상태 등 프로세스 실행에 필요한 모든 메타데이터를 포함합니다.

프로세스는 실행 과정에서 여러 상태를 거치며 전환됩니다. New는 프로세스가 생성되었으나 아직 메모리에 로드되지 않은 초기 상태이고 Ready는 메모리에 로드되었으며 CPU를 할당받기를 기다리는 상태이고 Running은 CPU를 할당받아 명령어를 실행 중인 상태, Blocked/Waiting은 작업 완료, 이벤트 발생 등 특정 사건을 기다리며 사용을 중단한 상태입니다.

#### 프로세스 생성 및 계층 구조

새로운 프로세스는 기존 프로세스에 의해 fork, exec 호출을 통해 생성됩니다. fork는 부모 프로세스의 주소 공간 복사본을 가진 자식 프로세스를 생성합니다. exec은 자식 프로세스의 주소 공간에 새로운 프로그램의 코드를 로드하여 실행합니다.

#### 스레드

프로세스 내에서 CPU 실행의 기본 단위입니다. 스레드는 CPU 상태(PC, 레지스터)와 스택만 독립적으로 가지며, 코드, 데이터, 힙 영역은 동일 프로세스 내의 다른 스레드와 공유합니다.

멀티프로세스는 각 프로세스가 독립된 주소 공간을 가지므로 보호 및 격리가 강력하지만, 프로세스 간 통신(IPC) 및 문맥 교환 오버헤드가 큽니다. 멀티스레딩은 스레드 간 메모리를 공유하므로 통신이 빠르며 문맥 교환 오버헤드가 상대적으로 작습니다.

사용자 스레드에서는 커널의 지원 없이 사용자 공간의 라이브러리에서 관리됩니다. 문맥 교환이 매우 빠르지만, 하나의 스레드가 I/O로 인해 블록되면 전체 프로세스가 블록됩니다. 커널 스레드는 운영체제 커널에 의해 직접 관리됩니다. 하나의 스레드가 블록되어도 다른 스레드는 계속 실행될 수 있습니다. 대부분의 현대 OS는 커널 스레드를 기본으로 사용합니다.

---

### CPU Scheduling

스케줄러는 Ready 상태의 프로세스들 중에서 다음에 CPU를 할당받아 실행될 프로세스를 선택하는 OS 모듈입니다. 장기 스케줄러는 Job 큐에서 Ready 큐로 로드할 프로세스를 선택합니다. 단기 스케줄러는 Ready 큐에서 CPU를 할당받을 다음 프로세스를 선택하며, 매우 빈번하게(밀리초 단위) 호출됩니다. 디스패처는 단기 스케줄러가 선택한 프로세스에게 실제로 CPU 제어권을 넘겨주는 모듈입니다.

#### 스케줄링 알고리즘 유형

FCFS는 먼저 도착한 프로세스에게 CPU를 먼저 할당합니다. 비선점형이며 짧은 프로세스가 긴 프로세스 뒤에 대기하는 Convoy Effect가 발생할 수 있습니다.

SJF는 CPU 버스트 시간이 가장 짧은 프로세스에게 우선권을 줍니다. 최소 평균 대기 시간을 보장하는 최적의 알고리즘이지만 시간을 정확히 예측하기 어렵다는 문제가 있습니다. 선점형과 비선점형 모두 가능합니다.

Round Robin은 각 프로세스에게 시간 할당량을 부여하고 그 시간 내에 CPU 사용을 완료하지 못하면 Ready 큐의 맨 뒤로 돌아갑니다. 대표적인 선점형 알고리즘이며, 응답 시간이 빠릅니다.

Priority Scheduling는 각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당합니다.

---

### Concurrency & Synchronization

여러 프로세스나 스레드가 동시에 접근하여 사용하는 메모리 변수, 파일, I/O 장치 등을 공유 자원이라고 하고 여러 프로세스가 동시에 공유 데이터를 접근하고 조작할 때, 접근 순서에 따라 결과가 달라지는 상황을 경쟁 조건이라고 말합니다. 공유 자원에 접근하는 코드의 특정 영역인 임계 구역에서 동시성 문제는 상호 배제(Mutual Exclusion)가 보장되지 않을 때 발생합니다.

동기화의 목표는 상호 배제, 진행(Progress), 유한 대기(Bounded Waiting)의 세 가지 조건을 만족시키는 것입니다.

Locks는 임계 구역에 진입하는 프로세스가 자원을 잠그고 작업을 마친 후 잠금을 해제하는 가장 기본적인 상호 배제 도구입니다. wait 연산은 세마포 값을 감소시키며, 값이 0 이하이면 대기합니다. signal 연산은 세마포 값을 증가시키며, 대기 중인 프로세스가 있으면 깨웁니다.

---

### Deadlock & Resource Allocation

교착 상태는 둘 이상의 프로세스가 상대방이 점유하고 있는 자원을 서로 기다리면서, 결과적으로 무한히 대기 상태에 빠지는 상태를 말합니다. 교착 상태가 발생하기 위해서는 다음 네 가지 조건이 모두 충족되어야 합니다.

상호 배제에 따라 최소한 하나의 자원이 비공유(Non-sharable) 방식으로 점유되어, 한 번에 오직 하나의 프로세스만 사용할 수 있어야 합니다. 자원을 하나 이상 점유하고 있는 프로세스가 다른 프로세스가 점유하고 있는 자원을 추가로 요청하며 대기해야 합니다. 이미 할당된 자원은 해당 자원을 점유하고 있는 프로세스가 자발적으로 해제하기 전까지는 강제로 빼앗을 수 없어야 합니다. 마지막으로 대기하고 있는 프로세스들이 자원을 점유하려는 방향이 순환 고리(Cycle)를 이루어야 합니다.

---

### 참고 자료

[원본 경로 #1](https://www.cis.upenn.edu/~lee/03cse380/lectures/ln2-process-v4.pdf)

[원본 경로 #2](https://www.cl.cam.ac.uk/teaching/1011/OpSystems/os1a-slides.pdf)