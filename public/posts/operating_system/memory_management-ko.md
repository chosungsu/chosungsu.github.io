---
title: 'Memory Management'
date: '2022-05-20'
tags: ['Operating System', 'lecture']
---

### Memory Management

물리 메모리는 컴퓨터 시스템에 실제로 존재하는 RAM 칩에 대한 주소 공간입니다. 이는 하드웨어 레벨의 실제 주소를 나타냅니다. 논리 메모리 또는 가상 주소 공간은 CPU가 생성하여 프로세스가 사용하는 주소 공간입니다. 프로세스는 독립적인 논리적 주소 공간을 가지며, 이 주소는 운영체제에 의해 실제 물리적 주소로 변환되어 사용됩니다. 베이스 레지스터는 프로세스의 논리적 주소 0이 매핑되는 물리적 시작 주소를 저장하고, 리미트 레지스터는 프로세스의 최대 크기를 저장합니다.

메모리에 프로세스를 배치하는 방식은 크게 두 가지로 나뉩니다.

연속 할당은 프로세스의 전체 논리적 주소 공간이 물리 메모리의 연속된 하나의 블록에 할당됩니다. 비연속 할당은 프로세스의 논리적 주소 공간이 물리 메모리의 여러 군데에 흩어져 할당됩니다.

#### 단편화

외부 단편화는 전체 물리 메모리 공간은 충분하지만, 프로세스가 요구하는 연속된 크기의 가용 공간이 없어 할당이 불가능한 상태입니다. 내부 단편화는 할당된 메모리 블록 크기가 프로세스가 요구하는 크기보다 커서 블록 내부에 사용되지 않고 남는 공간이 발생하는 현상입니다.

압축은 외부 단편화를 해결하기 위해 흩어진 가용 공간을 모아 하나의 큰 블록으로 만드는 작업입니다. 이는 많은 CPU 시간을 소모하고 시스템에 오버헤드를 유발합니다.

Buddy System은 메모리를 $2^k$ 크기의 덩어리로 관리하여 효율적으로 분할 및 병합하는 기법이며 Slab Allocator는 커널 내부에서 자주 사용되는 작은 크기의 객체를 캐싱하여 내부 단편화를 최소화하고 객체 생성/파괴 속도를 높입니다.

---

### 페이징, 세그먼테이션, 그리고 가상 메모리

페이징은 프로세스의 논리적 주소 공간을 페이지라는 고정된 크기의 블록으로 물리 메모리를 프레임(Frame)이라는 같은 크기의 블록으로 나누어 관리합니다. 논리적 주소는 페이지 번호와 오프셋으로 나뉘며 페이지 번호는 페이지 테이블을 통해 해당 페이지가 적재된 물리 메모리의 프레임 번호로 변환됩니다.

TLB(Translation Lookaside Buffer)는 작은 크기의 고속 하드웨어 캐시로 CPU가 메모리 접근을 할 때마다 주소 변환을 위해 페이지 테이블을 참조해야 하므로 두 번의 메모리 접근이 필요한 상황에서 최근에 변환된 논리적 주소와 물리적 주소 쌍을 저장하여 참조를 건너뛸 수 있게 합니다.

다단계 페이지 테이블은 64비트 시스템처럼 주소 공간이 매우 클 때 전체 페이지 테이블을 메모리에 저장하는 것은 낭비이므로 페이지 테이블 자체를 페이지로 나누어 관리하여 사용되지 않는 페이지 테이블은 메모리에 적재하지 않아 공간 효율성을 높입니다. 역 페이지 테이블은 시스템의 물리적 프레임 수만큼만 항목을 가지는 페이지 테이블입니다. 각 항목은 프로세스 ID와 논리적 페이지 번호를 저장합니다. 공간은 절약되지만 테이블 전체를 검색해야 하므로 시간이 더 걸릴 수 있습니다.

세그먼테이션은 프로세스의 논리적 주소 공간을 코드, 데이터, 스택 등 의미 있는 논리적 단위인 세그먼트로 나누어 관리합니다.

가상 메모리는 프로세스에게 물리 메모리의 크기와 관계없이 매우 큰 주소 공간을 제공하고 실제 필요한 코드와 데이터만 물리 메모리에 적재하는 기술입니다. 이는 프로그램의 크기가 물리 메모리보다 커도 실행할 수 있습니다. 그리고 CPU 이용률과 처리량이 증가합니다.

---

### 페이지 교체

Demand Paging은 프로세스가 실제로 필요로 하는 페이지만 메모리에 적재하고 나머지는 디스크(Swap Space)에 남겨둡니다. 대부분의 가상 메모리 시스템이 이 방식을 사용합니다. Page Fault는 CPU가 접근하려는 논리적 주소에 해당하는 페이지가 현재 물리 메모리에 없는 경우 발생하는 트랩(Trap)입니다. 따라서 이 때에는 디스크의 Swap Area에서 해당 페이지를 찾아 메모리의 빈 프레임에 로드합니다.

Thrashing은 프로세스가 실행 시간보다 Paging에 훨씬 많은 시간을 소비하는 현상으로 메모리 부족이 발생할 때 실행에 필요한 페이지를 연속적으로 찾지 못하고 Page Fault가 빈번하게 발생합니다. 그렇기 때문에 효율적으로 실행되기 위해 최소한 필요로 하는 페이지들의 집합을 워킹 셋이라고 합니다.

페이지 폴트가 발생했을 때 빈 프레임이 없는 경우 희생자 프레임(Victim Frame)을 선택하여 디스크로 내보내야 합니다. 이 때, 앞으로 가장 오랫동안 사용되지 않을 페이지를 선택하는 것이 최적의 알고리즘 목표입니다. FIFO는 메모리에 가장 먼저 들어온 페이지를 희생자로 선택합니다. LRU는 가장 오랫동안 사용되지 않은 페이지를 교체합니다. 과거의 사용 기록이 가까운 미래를 예측할 수 있다는 가정에 기반합니다. Clock Algorithm은 LRU의 현실적인 근사치로 각 페이지에 참조 비트를 두어 페이지 사용 여부를 기록합니다. 시계 방향으로 탐색하며 참조 비트가 0인 페이지를 교체하고, 1인 페이지는 0으로 초기화한 후 넘어갑니다.

---

### 참고 자료

[원본 경로 #1](https://www.cis.upenn.edu/~lee/03cse380/lectures/ln2-process-v4.pdf)

[원본 경로 #2](https://www.cl.cam.ac.uk/teaching/1011/OpSystems/os1a-slides.pdf)