---
title: 'Towards Reliable Code-as-Policies: A Neuro-Symbolic
Framework for Embodied Task Planning'
date: '2025-09-08'
tags: ['embodied ai', 'paper review']
---

### Abstract

거대 언어 모델 LLMs의 최근 발전은 로봇과 같은 구현체 에이전트(embodied agents)의 작업 계획 및 제어를 위한 실행 가능한 코드의 자동 생성을 가능하게 했으며, 이는 LLM 기반 구현 지능의 잠재력을 보여줍니다.

그러나 이러한 LLM 기반 '코드를 정책으로 사용하는 code-as-policies' 접근 방식은 종종 제한된 환경 기반화 environmental grounding로 인해 어려움을 겪으며, 특히 동적이거나 부분적으로 관찰 가능한 환경에서 부정확하거나 불완전한 코드 생성으로 이어져 최적이 아닌 작업 성공률을 초래합니다.

본 연구에서는 코드 생성 과정에서 명시적인 기호 검증 (symbolic verification) 및 상호 작용적 검증 (interactive validation) 프로세스를 통합하는 신경-기호적 구현 작업 계획 프레임워크를 제안합니다.

검증 단계에서, 이 프레임워크는 작업 관련 상태를 보존하면서 누락된 관찰 정보를 획득하기 위해 환경과 능동적으로 상호 작용하는 탐색적 코드를 생성합니다. 이 통합된 프로세스는 생성된 코드의 기반화를 강화하여 복잡한 환경에서 향상된 작업 신뢰도 및 성공률을 가져옵니다.

RLBench와 동적이고 부분적으로 관찰 가능한 시나리오를 아우르는 실제 환경에서 프레임워크를 평가합니다. 실험 결과는 프레임워크가 '코드를 정책으로 사용하는' 기준선 대비 작업 성공률을 $46.2\%$ 향상시키고 작업 관련 행동의 실행 가능성을 $86.8\%$ 이상 달성하여, 동적 환경에서 작업 계획의 신뢰도를 높임을 입증합니다.

---

### Introduction

<img src="https://velog.velcdn.com/images/devjo/post/63066a7c-01aa-4af4-a1b6-22792395dcc4/image.png" alt="Example Image" style="display: block; margin: 0 auto; height:150;" />

구현 제어 (embodied control) 분야의 최근 발전은 거대 언어 모델 (LLMs)을 활용하여 유연한 명령 따르기 (instruction following)를 가능하게 했으며, 이는 자연어 이해와 물리적 환경에서의 실행 가능한 행동을 효과적으로 연결합니다.

예를 들어, SayCan은 LLM 기반 작업 해석을 강화 학습 (RL) affordance model과 결합하여, "스펀지를 가져와"와 같은 고수준 언어 지침을 일련의 저수준, 사전 정의된 로봇 기술로 기반화하는 하이브리드 정책을 구축합니다.

이러한 기반 위에, 후속 접근 방식들은 코드를 정책으로 사용하는 (code-as-policies) 패러다임을 도입하여, 코드 생성을 통해 더 표현력이 풍부하고 구성 가능한 행동 명세 방식을 탐색했습니다. 이 패러다임에서 LLM은 구현체 에이전트를 제어하기 위한 실행 가능한 코드를 직접 생성합니다. 이러한 변화는 더 모듈화되고, 해석 가능하며, 다양한 환경에 적응 가능한 작업 계획을 가능하게 하며, 로봇 제어를 위한 범용 계획자로서 LLM의 잠재력을 강조합니다.

LLM 기반 '코드를 정책으로 사용하는' 접근 방식은 완전히 관찰 가능하고 잘 구조화된 환경에서 유망한 능력을 보여주었지만, 인지 입력이 종종 희소하거나, 지연되거나, 모호한 동적이거나 부분적으로 관찰 가능한 환경에서는 신뢰도가 저하됩니다. 이러한 한계는 부정확하거나 불완전한 코드 생성으로 이어지며, 궁극적으로 최적이 아닌 작업 성능을 초래합니다. 예를 들어, 정확한 깊이 또는 높이 추정치에 접근하지 않고 깨지기 쉬운 물체를 잡으려고 시도하면 물체를 떨어뜨리거나 손상시켜 작업 완료를 방해할 수 있습니다. 이러한 문제점들은 구현체 에이전트가 탐색적이지만 안전한 상호 작용을 통해 불확실성에 대해 명시적으로 추론하고, 실행에 앞서 생성된 코드의 정확성을 검증해야 할 결정적인 필요성을 강조합니다.

#### Proposed Framework: NESYRO

코드 생성 과정에서 명시적인 기호 검증 (symbolic verification) 및 상호 작용적 검증 (interactive validation) 프로세스를 통합하는 신경-기호적 로봇 작업 계획 프레임워크, NESYRO를 제안합니다. 오랜 소프트웨어 공학 원칙인 검증 및 확인 ($\text{V\&V}$)에서 영감을 받아, 프레임워크는 두 가지 핵심 프로세스를 구별합니다.

$\Rightarrow$ 검증 (Verification)은 생성된 코드가 논리적으로 일관성이 있으며 기호적 전제 조건을 충족하는지 확인합니다.

$\Rightarrow$ 확인 (Validation)은 코드가 현재 환경 및 작업 목표에 적합한지 평가합니다.

코드 정확성에 대한 기호 검증 후, 상호 작용적 확인 단계는 전제 조건을 식별하고, 그 전제 조건을 효과 (effects)로서 확립하는 탐색적 행동을 호출함으로써 각 기술을 기반화합니다. 이로써 의도한 기술을 가능하게 하도록 환경 상태를 변환합니다. 이 프로세스는 백트래킹 탐색 (backtracking search)의 한 형태와 유사하며, 에이전트는 환경을 탐색하여 유효한 실행 경로를 구성하고, 현재 관찰 및 기호 도구의 피드백을 기반으로 코드를 점진적으로 검증하고 확인합니다.

---

### Related Works

#### 1. LLM-based embodied control

구현 제어 분야에서는 LLM을 추론 및 계획 작업에 활용하는 새로운 경향이 나타나고 있습니다. 고수준 추론 능력을 기반으로, 최근 접근 방식들은 실행 가능한 코드를 직접적인 제어 정책으로 생성하는 방식을 탐색해 왔으며 이는 종종 '코드를 정책으로 사용하는 (code-as-policies)' 패러다임이라고 불립니다. 이러한 방법들은 명령을 미리 정의된 기술이나 이산적인 행동 기본 요소에 매핑하는 대신 LLM이 로봇과 같은 구현체 에이전트에 의해 직접 실행될 수 있는 파이썬과 유사한 스크립트를 생성하도록 유도합니다. LLM이 저수준 제어 논리를 합성할 수 있음을 보여주며, 다양한 범위의 작업에서 더 큰 유연성과 일반화를 가능하게 합니다.

하지만, 동적이거나 부분적으로 관찰 가능한 설정에서는 생성된 코드가 종종 적절한 기반화 (grounding)가 부족하여 불완전하거나 실행 불가능한 출력을 초래합니다. 이러한 문제를 완화하기 위해, NESYRO는 코드 생성 프로세스에 명시적인 피드백을 통합함으로써 생성된 코드의 환경 기반화 및 신뢰성을 향상시킵니다.

#### 2. Neuro-symbolic system

최근의 신경-기호 시스템은 LLM의 일반화 능력을 기호 추론 도구의 견고성 및 해석 가능성과 결합합니다. 이 하이브리드 접근 방식은 기호 문제 해결, 계획, 프로그램 합성과 같은 분야에서 활발하게 연구되어 왔습니다. 구현체 에이전트의 신경-기호적 접근 방식은 일반적으로 LLM을 인식 및 자연어 지침 이해에 활용하는 동시에, 기호 도구를 사용하여 고수준 작업 계획을 수행합니다. 그러나 기존의 신경-기호 에이전트들은 고정된 모듈형 구조나 미리 정의된 절차에 의존하여, 누락된 관찰 정보 및 환경 불확실성에 대한 적응성이 제한적입니다. NESYRO는 기호 추론을 상호 작용적 확인 및 탐색적 상호 작용과 통합하여 동적 환경에서 신뢰할 수 있는 작업 계획을 가능하게 합니다.

---

### Methods

환경은 부분 관찰 가능 마르코프 결정 과정 (Partially Observable Markov Decision Process, POMDP) $M = (S, A, G, T, R, \Omega, O)$으로 모델링됩니다.

$s \in S$는 상태, $a \in A$는 행동, $g \in G$는 고수준 목표 ("빨간 머그잔을 집어라"와 같은)입니다. $T : S \times A \to S$는 역학을 설명하는 전이 함수입니다. 보상 함수 $R : S \times A \times G \to {0, 1}$는 이진 성공 신호를 반환하는데, 이는 작업 완료만 관찰 가능한 로봇 공학에서 흔한 방식입니다. 부분 관찰 가능성 때문에, 관찰 정보 $o \in \Omega$는 $O : S \times A \to \Omega$를 통해 수신되며, 관찰 정보는 구조화된 술어 기반 표현 (예: is_locked(drawer), on(object, surface))으로 구성된 기호적 형태로 표현됩니다.

코드를 정책으로 사용하는 (code-as-policies) 패러다임 하에서, LLM은 관찰 기록과 목표를 입력으로 받아 정책 코드 $\pi$를 생성하고 내부적으로 작업을 완료하는 데 필요한 행동을 인코딩합니다. 목표는 예상 수익을 최대화하는 정책 코드 $\pi^*$를 찾는 것입니다.

$$
\pi^* = \operatorname*{argmax}_{\pi \in \Pi} \mathbb{E}_{g \sim G, \tau \sim P(\text{exe}(\pi), g)} \left[ \sum_{t=0}^{\infty} R(s_t, \text{exe}(\pi)(o_{\le t}), g) \right]
$$

여기서 $\tau = (s_0, o_0, a_0, s_1, o_1, a_1, \dots)$는 환경에서 $exe(\pi)$를 실행하여 생성된 궤적을 나타내며, $P(exe(\pi), g)$는 $g, T, O$ 하에서 $exe(\pi)$에 의해 유도된 결과 궤적 분포입니다. 구현에서 $\tau$의 각 행동 $a_t$는 $\pi$ 내에 인코딩된 다수의 저수준 제어로 구성된 기술 함수에 해당합니다. $M$이 부분적으로 관찰 가능하기 때문에, $\pi^*$는 탐색 (불확실성 감소)과 활용 (목표 달성) 사이의 균형을 유지해야 하며, 동적 환경에서 신뢰할 수 있는 작업 계획을 보장해야 합니다.

<img src="https://velog.velcdn.com/images/devjo/post/07058e5f-9e73-4e36-80d4-2834bd1289a9/image.png" alt="Example Image" style="display: block; margin: 0 auto; height:150;" />

NESYRO는 생성된 작업 명세에 대한 정책 코드의 논리적 정확성을 보장하는 단계와 기술의 기반화를 평가하고 개선하여 환경적 실행 가능성을 보장하는 단계 두 가지로 작동합니다.

검증 단계 (1단계)에서는, 언어 지침 $g$와 현재 관찰 $o_{\le t}$가 주어지면, LLM은 초기 정책 코드 $\pi_{\text{main}}$와 함께 작업 명세 $T_{\text{spec}}$를 생성합니다. 그런 다음 기호 도구는 $\pi_{\text{main}}$이 $T_{\text{spec}}$를 충족하는지 검증합니다. 검증에 실패하면 기호 도구는 LLM에 피드백을 제공하고, 검증된 버전이 얻어질 때까지 $\pi_{\text{main}}$을 반복적으로 개선합니다.

확인 단계 (2단계)에서는, $\pi_{\text{main}}$에 정의된 기술들의 시퀀스가 기호적 실행 가능성과 상식적 타당성을 통합하는 신경-기호적 신뢰 점수 (NeSyConf)를 사용하여 순차적으로 확인됩니다. 기술의 신뢰 점수가 임계값 $\epsilon$ 미만으로 떨어지면, NESYRO는 누락된 관찰 정보를 복구하기 위해 안전한 탐색 정책 코드 $\pi_{\text{probe}}$를 합성합니다. $\pi_{\text{probe}}$는 모든 기술이 기반화될 때까지 검증 및 확인 단계의 구성을 통해 재귀적으로 처리됩니다.이러한 재귀적 구조는 $\pi_{\text{main}}$에 뿌리를 둔 정책 트리를 유도하며, 각 $\pi_{\text{probe}}$는 자신의 부모의 성공적인 확인을 가능하게 하는 서브루틴 역할을 합니다. 모든 필수 관찰 정보가 획득되고 $\pi_{\text{main}}$의 모든 기술이 확인될 때까지 재귀적 프로세스는 계속됩니다. 최종 출력은 $T_{\text{spec}}$와 현재 환경에 모두 부합하는 $\pi_{\text{main}}$의 기반화된 버전입니다.

#### Neuro-symbolic Code Verification

LLM-based code generation에서 언어 지침 $g$와 관찰 $o_{\le t}$가 주어지면, 검증 LLM ($\Phi_{\text{veri}}$)은 사고의 사슬 (CoT) 방식으로 추론하도록 유도되어, 핵심 목표와 제약 조건을 작업 명세 $T_{\text{spec}}$로 합성합니다. 그런 다음 이 명세를 사용하여 정책 코드 $\pi_{\text{main}}^i$를 생성합니다. 이는 매개변수 및 필수 라이브러리와 함께 기술의 시퀀스를 정의합니다.

$$
\Phi_{\text{veri}} : (o_{\le t}, g, l_{\text{cot}}, D, \pi_{\text{main}}^{i-1}, F_{\text{veri}}^{i-1}, n) \to (T_{\text{spec}}, \pi_{\text{main}}^i)
$$

여기서 $o_{\le t}$는 현재 관찰입니다. $l_{\text{cot}}$는 $\Phi_{\text{veri}}$가 명세를 중간 단계로 생성하도록 안내하는 $\text{CoT}$ 프롬프트입니다. $D$는 도메인 지식을 나타내며, 이는 매개변수화된 함수 호출로 표현된 사용 가능한 기술과 환경에 이러한 기술을 매핑하는 객체 유형 및 속성으로 구성됩니다. $F_{\text{veri}}^{i-1}$는 이전 반복의 검증 피드백이며, LLM이 수정된 $\pi_{\text{main}}^i$를 생성하는 데 사용됩니다. $n$은 코드 개선이 시작되는 $\pi_{\text{main}}$의 기술 함수 호출 순서를 나타내며, $n$ 이전의 호출은 변경되지 않고 유지됩니다. $n=0$일 때는 초기 코드 생성에 해당합니다. 결과 $T_{\text{spec}}$는 $g$와 $o_{\le t}$에서 파생된 고수준 의도, 제약 조건 및 관련 하위 목표를 포착합니다. 그런 다음 $\pi_{\text{main}}^i$는 기호 검증 도구로 전달됩니다.

다음으로, 기호 검증 도구 ($\Psi_{\text{veri}}$)는 $\pi_{\text{main}}^i$가 $T_{\text{spec}}$를 충족하는지 확인하여 명세에 정의된 제약 조건의 위반을 식별합니다.

$$
\Psi_{\text{veri}} : (T_{\text{spec}}, \pi_{\text{main}}^i) \to \begin{cases} \text{verified } \pi_{\text{main}} \\ F_{\text{veri}}^i\end{cases}
$$

검증에 실패하면 $\Psi_{\text{veri}}$는 $T_{\text{spec}}$를 위반하는 $\pi_{\text{main}}^i$의 특정 부분을 식별하는 상세한 $F_{\text{veri}}^i$를 제공합니다. 이 피드백은 수정된 $\pi_{\text{main}}^i$를 생성하기 위해 다음 $\Phi_{\text{veri}}$ 반복으로 전달됩니다. $\pi_{\text{main}}^i$가 검증에 통과하여 $\pi_{\text{main}}$의 검증된 버전이 되면, 신경-기호적 코드 확인 단계로 진행합니다.

#### Neuro-symbolic Code Validation

검증된 정책 코드 $\pi_{\text{main}}$은 기술 함수 호출의 시퀀스 $\pi_{\text{main}} = (f_0, f_1, \dots, f_N)$로 구문 분석되며, 여기서 $N$은 최대 기술 단계를 나타냅니다. 전체 $\pi_{\text{main}}$에 대해 총체적으로 추론하는 신경-기호적 코드 검증 단계와 달리, 확인 프로세스는 현재 환경에서의 실행 가능성을 평가하고 개선하기 위해 각 기술을 순차적으로 평가합니다.

기술 실행 가능성을 평가하기 위해, 우리는 확인 LLM ($\Phi_{\text{vali}}$)의 상식적 신뢰도 (CSC)와 기호적 확인 도구 ($\Psi_{\text{vali}}$)의 논리적 신뢰도 (LC)를 병렬로 결합하는 신경-기호적 신뢰 점수 (NeSyConf)를 도입합니다.

$$
\begin{aligned}
&\Phi_{\text{vali}} : (D, E_{\text{demo}}, o_{\le t}, g, f_n) \to \text{CSC}_{f_n} \\
&\Psi_{\text{vali}} : (D, o_{\le t}, g, f_n) \to \text{LC}_{f_n}
\end{aligned}
$$

$\text{CSC}{f_n}$은 도메인 지식 $D$와 검색된 데모 $E{\text{demo}}$를 기반으로, 주어진 기술 $f_n \in \pi_{\text{main}}$이 현재 관찰 $o_{\le t}$ 및 지침 $g$ 하에서 성공할 가능성을 추정합니다. 논리 기반 신뢰도 $\text{LC}_{f_n}$는 기호적 확인 도구에 의해 계산되며, 이는 $f_n$이 $o_{\le t}, g, D$ 하에서 기호적으로 실행 가능한지 평가합니다. $\text{NeSyConf}{f_n}$은 $\text{CSC}{f_n}$와 $\text{LC}_{f_n}$를 곱하여 계산되는 $f_n$의 최종 신뢰 점수를 나타냅니다.

---

### Conclusion

본 연구에서 동적이고 부분적으로 관찰 가능한 설정 하에서 신뢰할 수 있는 로봇 제어 코드를 생성하기 위해 신경-기호적 코드 검증과 신경-기호적 코드 확인을 통합한 신경-기호적 프레임워크인 NESYRO를 제시했습니다.

이 프레임워크는 기호 검증과 상호 작용적 확인을 번갈아 수행하는 재귀적 프로세스를 통해 작동하며, 각 기술이 논리적으로 일관되고 환경적으로 기반화되도록 보장합니다. 상식 및 논리 기반 추론을 결합한 신경-기호적 신뢰 추정을 통합함으로써, NESYRO는 불확실성 하에서 탐색적이면서도 안전한 상호 작용 및 적응형 코드 개선을 가능하게 합니다. 시뮬레이션 및 실제 환경에서의 광범위한 평가는 다양한 작업에서 NESYRO의 강력한 성능을 입증합니다.

NESYRO의 현재 구현은 이진 LC와 미리 정의된 도메인 지식을 사용하며, 이는 실제 응용 분야에서의 일반성을 제한합니다. 향후 연구에서는 확률적 PDDL과 같은 확률적 및 시간적 추론을 통합하여 이 한계를 해결할 것입니다. 또한, 이러한 가정을 완화하고 도메인 지식에 명시적으로 정의되지 않은 기술로 확인 프로세스를 확장함으로써 더 다양하고 동적인 도메인에 대한 프레임워크의 적용 가능성을 탐색할 계획입니다.

---

### 참고 자료

[원본 경로 #1](https://arxiv.org/pdf/2510.21302)
